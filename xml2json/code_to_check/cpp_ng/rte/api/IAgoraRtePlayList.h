//
//  Agora Rtc Engine SDK
//
//  Copyright (c) 2021 Agora.io. All rights reserved.
//

#pragma once

#include "AgoraRteBase.h"

namespace agora {
namespace rte {

/**
 * The RTE file information structure.
 */
#define INVALID_RTE_FILE_ID (-1)

struct RteFileInfo {
  int32_t file_id;  ///< the UUID of media file, it's generated by RTE sdk
  std::string
      file_url;      ///< the absolute path of local file or url of cloud file
  int64_t duration;  ///< the duration of this media file
  int32_t video_width;   ///< the width of video frame
  int32_t video_height;  ///< the height of video frame
  int32_t frame_rate;    ///< the frame rate of video
  int32_t
      index;  ///< file index in list, it will be updated after remove/insert
  int64_t begin_time;  ///< the begin timestamp in the list, it will be updated
                       ///< after remove/insert

  RteFileInfo() {
    file_id = INVALID_RTE_FILE_ID;
    file_url = "";
    duration = 0;
    video_width = 0;
    video_height = 0;
    frame_rate = 0;
    index = -1;
    begin_time = 0;
  }

  void Reset() {
    file_id = INVALID_RTE_FILE_ID;
    file_url = "";
    duration = 0;
    video_width = 0;
    video_height = 0;
    frame_rate = 0;
    index = -1;
    begin_time = 0;
  }

  bool IsValid() const { return (file_id != INVALID_RTE_FILE_ID); }

  void CloneTo(RteFileInfo& out_file_info) const {
    out_file_info.file_id = file_id;
    out_file_info.file_url = file_url;
    out_file_info.video_width = video_width;
    out_file_info.video_height = video_height;
    out_file_info.frame_rate = frame_rate;
    out_file_info.index = index;
    out_file_info.begin_time = begin_time;
  }
};
using RteFileInfoSharePtr = std::shared_ptr<RteFileInfo>;

/**
 * The RTE play list class.
 */
class IAgoraRtePlayList {
 public:
  /**
   * @brief Clear all files in current list
   *        If there is a current file, it will return ERR_ALREADY_IN_USE
   * @param None
   * @return Error code: <0: failure;  >=0: success
   */
  virtual int ClearFileList() = 0;

  /**
   * @brief Retrieve the file count of current list
   * @param None
   * @return The number of files in current list
   */
  virtual int32_t GetFileCount() = 0;

  /**
   * @brief Gets the total duration of the list
   * @param None
   * @return The summarization of each file duration
   */
  virtual int64_t GetTotalDuration() = 0;

  /**
   * @brief Get file information by file Id
   * @param file_id : the query file id
   * @param out_file_info :  output file information
   * @return Error code:  <0: failure;  >=0: success
   */
  virtual int GetFileInfoById(int32_t file_id, RteFileInfo& out_file_info) = 0;

  /**
   * @brief Get file information by file index
   * @param file_index : the query file index
   * @param out_file_info :  output file information
   * @return Error code:  <0: failure;  >=0: success
   */
  virtual int GetFileInfoByIndex(int32_t file_index,
                                 RteFileInfo& out_file_info) = 0;

  /**
   * @brief Get First file info
   * @param first_file_info :  output first file information
   * @return Error code:  <0: failure;  >=0: success
   */
  virtual int GetFirstFileInfo(RteFileInfo& first_file_info) = 0;

  /**
   * @brief Get Last file info
   * @param last_file_info :  output last file information
   * @return Error code:  <0: failure;  >=0: success
   */
  virtual int GetLastFileInfo(RteFileInfo& last_file_info) = 0;

  /**
   * @brief Get the file information list of current list
   * @param out_file_list : output the file list
   * @return Error code: <0: failure;  >=0: success
   */
  virtual int GetFileList(std::vector<RteFileInfo>& out_file_list) = 0;

  /**
   * @brief Insert new file into the play list at the specified position.
   * @param file_url : The absolute path of local file or URL for cloud file
   * @param insert_index : the index of want to insert, range in [0,
   * (file_count-1)] insert_index <= 0: insert into head of list insert_index >=
   * file_count: insert into tail of list
   * @param [out] out_file_info: output the file information
   * @return Error code:  <0: failure;  >=0: success
   */
  virtual int InsertFile(const char* file_url, int32_t insert_index,
                         RteFileInfo& out_file_info) = 0;

  /**
   * @brief Appends a new file to the end of the play list.
   * @param file_url : the file path url
   * @param [out] out_file_info: output the file information
   * @return Error code:  <0: failure;  >=0: success
   */
  virtual int AppendFile(const char* file_url, RteFileInfo& out_file_info) = 0;

  /**
   * @brief Removes a file by file ID from the play list.
   *        If removing current file, it will return @agora::ERR_ALREADY_IN_USE
   * @param remove_file_id : the file UUID which want to be removed
   * @return Error code:  <0: failure;  >=0: success
   */
  virtual int RemoveFileById(int32_t remove_file_id) = 0;

  /**
   * @brief Removes a file by index.
   *        If removing current file, it will return @agora::ERR_ALREADY_IN_USE
   * @param remove_file_index : The index of the file to be removed.
   * @return Error code:  <0: failure;  >=0: success
   */
  virtual int RemoveFileByIndex(int32_t remove_file_index) = 0;

  /**
   * @brief Removes all files by URL.
   *        If removing current file, it will return @agora::ERR_ALREADY_IN_USE
   * @param remove_file_url : The URL of the file to be removed.
   * @return Error code:  <0: failure;  >=0: success
   */
  virtual int RemoveFileByUrl(const char* remove_file_url) = 0;
};

}  // namespace rte
}  // namespace agora
