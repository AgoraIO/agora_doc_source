## 概述

为降低开发者集成难度，声网为 K 歌房场景提供了定制化场景 API。定制化场景 API 基于场景业务代码逻辑封装了声网音视频 SDK API，让你只需调用一个定制化 API，即可实现通过多个音视频 API 和复杂的代码逻辑才可实现的 K 歌业务功能，例如将合唱和伴唱端进行 NTP 时间同步。声网在 GitHub 上提供 KTV 场景化 API 的源码文件 [KTVApi.kt](https://github.com/AgoraIO-Usecase/agora-ent-scenarios/blob/v2.1.1-ktv-Android/Android/scenes/ktv/src/main/java/io/agora/scene/ktv/live/KTVApi.kt) 和 [KTVApiImpl.kt](https://github.com/AgoraIO-Usecase/agora-ent-scenarios/blob/v2.1.1-ktv-Android/Android/scenes/ktv/src/main/java/io/agora/scene/ktv/live/KTVApiImpl.kt)。

本文介绍如何使用 KTV 场景化 API 实现点歌、独唱、合唱等基础业务功能。

## 前提条件

实现点歌、独唱、合唱前，请确保你已完成如下步骤：

1. 参考<a href="https://docs.agora.io/cn/online-ktv/chorus_client_android?platform=Android#项目配置">项目配置</a>集成所需 SDK。
2. 在工程文件中引入 [KTVApi.kt](https://github.com/AgoraIO-Usecase/agora-ent-scenarios/blob/v2.1.1-ktv-Android/Android/scenes/ktv/src/main/java/io/agora/scene/ktv/live/KTVApi.kt) 和 [KTVApiImpl.kt](https://github.com/AgoraIO-Usecase/agora-ent-scenarios/blob/v2.1.1-ktv-Android/Android/scenes/ktv/src/main/java/io/agora/scene/ktv/live/KTVApiImpl.kt) 文件。

## 点歌

本节介绍如何实现点歌功能。用户需要在唱歌前进行点歌。点歌指用户通过浏览榜单或搜索关键词选定想唱的正版音乐，然后下载播放音乐。

### 方案介绍

下图展示点歌的 API 调用时序图：

![](https://web-cdn.agora.io/docs-files/1678788543385)

### 1. 初始化 KTV API 模块

实例化 `rtcEngine`、`musicCenter`、`mediaPlayer`、`streamId` 实例，并将它们通过 `initWithRtcEngine` 方法传入 KTV API 模块。调用 KTV API 模块的 API 前，请确保已调用 `initWithRtcEngine` 初始化 KTV API 实例。

<div class="alert note">考虑到数据流的消息通道有频率限制，为了确保 KTV 模块和其他模块不会相互影响，声网建议你在不同模块中为数据流创建的 <code>streamId</code> 都不同。例如，如果你在其他模块中也使用 <code>sendStreamMessage</code>，请确保两个模块中创建的 <code>streamId</code> 不同。同时，每个用户在每个频道中最多只能创建 5 个数据流，请不要超出上限。</div>

1. 调用 [`create`](https://docs.agora.io/cn/online-ktv/API%20Reference/java_ng/API/toc_core_method.html#api_irtcengine_initialize) 初始化 `RtcEngine`。

    ```Kotlin
    // 初始化 RtcEngine
    val config = RtcEngineConfig()
    config.mContext = null
    config.mAppId = "<Your_Agora_Appid>"
    config.mEventHandler = object : IRtcEngineEventHandler() {}
    config.mChannelProfile = CHANNEL_PROFILE_LIVE_BROADCASTING
    config.mAudioScenario = AUDIO_SCENARIO_CHORUS
    val mRtcEngine = RtcEngine.create(config) as RtcEngineEx
    ```

2. 调用 [`initialize`](https://docs.agora.io/cn/online-ktv/API%20Reference/java_ng/API/toc_drm.html#api_imusiccontentcenter_initialize) 初始化 `IAgoraMusicContentCenter`。示例代码中需要传入 RTM Token。你可以参考[获取 RTM Token](/cn/Agora%20Platform/get_appid_token?platform=All%20Platforms#获取-rtm-token) 了解什么是 RTM Token，如何获取测试用途的临时 RTM Token，如何从服务器生成 RTM Token。

    ```Kotlin
    // 初始化 IAgoraMusicContentCenter
    val contentCenterConfiguration = MusicContentCenterConfiguration()
    contentCenterConfiguration.appId = "<Your_Agora_Appid>"
    contentCenterConfiguration.mccUid = <Your_Local_Uid>
    contentCenterConfiguration.token = "<Your_Rtm_Token>"
    val iAgoraMusicContentCenter = IAgoraMusicContentCenter.create(mRtcEngine)
    iAgoraMusicContentCenter.initialize(contentCenterConfiguration)
    ```

3. 调用 [`createMusicPlayer`](https://docs.agora.io/cn/online-ktv/API%20Reference/java_ng/API/toc_mediaplayer.html#api_irtcengine_createmediaplayer) 创建 Media Player。

    ```Kotlin
    // 创建 media player
    val mPlayer = iAgoraMusicContentCenter.createMusicPlayer()
    ```

4. 调用 [`createDataStream`](https://docs.agora.io/cn/online-ktv/API%20Reference/java_ng/API/toc_network.html#api_irtcengine_createdatastream2) 创建数据流。

    ```Kotlin
    // 创建数据流
    val cfg = DataStreamConfig()
    cfg.syncWithAudio = false
    cfg.ordered = false
    val streamId = mRtcEngine.createDataStream(cfg)
    ```

5. 调用 `initWithRtcEngine` 初始化 KTV API 实例。

    ```Kotlin
    // 初始化 KTV API 实例
    val ktvApiProtocol = KTVApiImpl()
    ktvApiProtocol.initWithRtcEngine(mRtcEngine, <Your_Channel_Name>, iAgoraMusicContentCenter, mPlayer, streamId, object: KTVApiEventHandler {})
    ```

### 2. 获取歌曲列表

通过关键词搜索或音乐榜单获取歌曲列表。

```Kotlin
// 用关键词搜索歌曲
fun searchSong(condition: String, page: Int) {
    // 搜索过滤条件
    val jsonOption = "{\"pitchType\":1,\"needLyric\":true}"
    val requestId = iAgoraMusicContentCenter.searchMusic(condition, page, 50, jsonOption)
}

// IMusicContentCenterEventHandler
// 报告搜索结果
override fun onMusicCollectionResult(
	requestId: String?,
	status: Int,
    page: Int,
    pageSize: Int,
    total: Int,
    list: Array<out Music>?
) {}
```

```Kotlin
// 用音乐榜单获取歌曲
fun searchSongWithRankingChartId(type: Int, page: Int) {
    // 搜索过滤条件
    val jsonOption = "{\"pitchType\":1,\"needLyric\":true}"
    val requestId = iAgoraMusicContentCenter.getMusicCollectionByMusicChartId(condition, page, 50, jsonOption)
}

// IMusicContentCenterEventHandler
// 报告搜索结果
override fun onMusicChartsResult(
    requestId: String?,
    status: Int,
    list: Array<out MusicChartInfo>?
) {}
```

### 3. 加载歌曲

调用 `loadSong` 加载歌曲。该方法中你需要参入编曲编号和 K 歌配置，例如当前的 K 歌唱的场景（合唱或伴唱）、用户角色、主唱伴唱的 UID。K 歌配置会决定 K 歌时歌曲的播放情况、各端用户的收发流情况等。歌曲加载结果会异步地通过 `onLoaded` 回调通知你。

```Kotlin
// isChorus: 歌曲是否合唱
// isOwnSong: 是否为自己点的歌，点歌者默认为主唱
// isChorusMem: 是否为伴唱点的歌
val type = if (isChorus) KTVSongType.KTVSongTypeChorus else KTVSongType.KTVSongTypeSolo
val role = if (isOwnSong) KTVSingRole.KTVSingRoleMainSinger else if (isChorusMem) KTVSingRole.KTVSingRoleCoSinger else KTVSingRole.KTVSingRoleAudience
// 主唱 UID
val mainSingerUid = <Main_Singer_UID>
// 伴唱 UID。如果是独唱场景，不存在伴唱角色，那么传入 0 即可。
val coSingerUid = <Chorus_Singer_UID>

// 加载歌曲
ktvApiProtocol.loadSong(
    songCode,
	KTVSongConfiguration(type, role, songCode, mainSingerUid, coSingerUid)
) { song, lyricUrl, singRole, singState ->
    if (singState === KTVLoadSongState.KTVLoadSongStateOK) {
        // 歌曲加载成功的操作
        ...
	} else if (singState == KTVLoadSongState.KTVLoadSongStatePreloadFail) {
	    // 歌曲加载失败的操作
        ...
	} else if (singState == KTVLoadSongState.KTVLoadSongStateNoLyricUrl) {
        // 歌曲没有歌词的操作
        ...
	}
}
```

### 4. 播放歌曲

收到 `onLoaded(KTVLoadSongStateOK)` 回调状态后，调用 `playSong` 开始播放歌曲。

```Kotlin
ktvApiProtocol.loadSong(
    songCode,
	KTVSongConfiguration(type, role, songCode, mainSingerUid, coSingerUid)
) { song, lyricUrl, singRole, singState ->
    if (singState === KTVLoadSongState.KTVLoadSongStateOK) {
        // 歌曲加载成功，则播放歌曲
		ktvApiProtocol.playSong()
    } else {
		// 否则进行其他操作
        ...
	}
}
```

### 5. 监听并控制歌曲播放

歌曲播放时，音乐播放器会通过 `onPlayerStateChanged` 回调向业务层通知歌曲播放状态改变。收到 `onPlayerStateChanged(PLAYER_STATE_PLAYING)` 回调后，你可以使用 `seek`、`pause`、`resume`、`selectAudioTrack` 等方法控制播放器。

<div class="alert note">KTV API 模块内部会自动处理播放器同步，因此你也可以通过 <code>onPlayerStateChanged</code> 回调获取远端播放器的状态。</div>

```Kotlin
// 跳转到指定时间播放歌曲
ktvApiProtocol.seek(time)
```

### 6. 停止歌曲播放

当歌曲播放完成或用户中途结束播放时，你需要主动调用 `stopSong` 停止播放。

```Kotlin
ktvApiProtocol.stopSong()
```

### 7. 释放资源

当退出 K 歌场景时，你需要调用 `release` 释放 KTV API 模块内的资源和取消注册事件回调。

```Kotlin
ktvApiProtocol.release()
```

## 独唱

本节介绍如何实现独唱功能。主唱点歌后，可以开始独唱，K 歌房内的听众都可以听到这位主唱唱歌。房间内想与主唱连麦语聊的听众可以上麦。

### 方案介绍

独唱场景下存在两种角色：

- 主唱：加入频道，加载并播放歌曲。KTV API 模块内部控制音乐播放器播放音乐，发布音乐到远端，将音乐播放进度同步到远端，让歌词组件进入歌词滚动状态等逻辑。
- 听众：加入频道，加载歌曲。KTV API 模块内部控制听众订阅主唱的人声和音乐的音频合流，同步主唱的音乐播放进度，让歌词组件进入歌词滚动状态等逻辑。如果普通观众需要上麦聊天，可以更新媒体选项。

![](https://web-cdn.agora.io/docs-files/1678784206362)

下图展示独唱的 API 调用时序图：

![](https://web-cdn.agora.io/docs-files/1678788551670)

### 主唱实现

#### 1. 加入频道

调用 [`joinChannel`](https://docs.agora.io/cn/online-ktv/API%20Reference/java_ng/API/toc_core_method.html#api_irtcengine_joinchannel2) 让主唱加入频道。

```Kotlin
// 加入频道
mRtcEngine.joinChannel(
	<Your_Rtc_Token>,
	<Your_Channel_Name>,
	<Your_Uid>,
    // 媒体选项详见第 5 步操作
	channelMediaOption
)
```

#### 2. 播放歌曲

调用 `loadSong` 加载歌曲。歌曲加载结果会异步地通过 `onLoaded` 回调通知你。收到 `onLoaded(KTVLoadSongStateOK)` 回调状态后，调用 `playSong` 开始播放歌曲。

```Kotlin
ktvApiProtocol.loadSong(
    "ABCDEFG", KTVSongConfiguration(KTVSongType.KTVSongTypeSolo, KTVSingRole.KTVSingRoleMainSinger, "ABCDEFG", 12345, 0)
) { songCode, lyricUrl, singRole, singState ->
    if (singState === KTVLoadSongState.KTVLoadSongStateOK) {
        // 歌曲加载成功，则播放歌曲
        ktvApiProtocol.playSong(songCode)
    }
}
```

#### 3. 停止播放

当歌曲播放完成或用户中途结束播放时，你需要主动调用 `stopSong` 停止播放。

```Kotlin
ktvApiProtocol.stopSong()
```

#### 4. 关闭麦克风

主唱停止唱歌或希望暂时关闭麦克风时，可以调用 [`adjustRecordingSignalVolume`](https://docs.agora.io/cn/online-ktv/API%20Reference/java_ng/API/toc_audio_process.html#api_irtcengine_adjustrecordingsignalvolume)，将音频采集信号音量设置为 0。

```Kotlin
mRtcEngine.adjustRecordingSignalVolume(0)
```

#### 5. 根据角色更新媒体选项

通过 [`updateChannelMediaOptions`](https://docs.agora.io/cn/online-ktv/API%20Reference/java_ng/API/toc_core_method.html#api_irtcengine_updatechannelmediaoptions) 方法在主播加入频道后更新频道媒体选项，例如是否开启本地音频采集，是否发布本地音频流等。

```Kotlin
val channelMediaOption = ChannelMediaOptions()
// 发布本地麦克风流
channelMediaOption.publishMicrophoneTrack = true
// 启用音频采集和播放
channelMediaOption.enableAudioRecordingOrPlayout = true
// 设置角色为主播
channelMediaOption.clientRoleType = CLIENT_ROLE_BROADCASTER
// 更新媒体选项
mRtcEngine.updateChannelMediaOptions(channelMediaOption)
```

### 听众实现

#### 1. 加入频道

调用 [`joinChannel`](https://docs.agora.io/cn/online-ktv/API%20Reference/java_ng/API/toc_core_method.html#api_irtcengine_joinchannel2) 让听众加入频道。

```Kotlin
// 加入频道
mRtcEngine.joinChannel(
	<Your_Rtc_Token>,
	<Your_Channel_Name>,
	<Your_Uid>,
    // 媒体选项详见第 4 步操作
	channelMediaOption
)
```

#### 2. 加载歌曲

调用 `loadSong` 加载歌曲。加载结果会异步地通过 `onLoaded` 回调通知你。收到 `onLoaded(KTVLoadSongStateOK)` 回调状态后，调用 `playSong`。

听众加入频道后，默认订阅主唱发布的音频合流，即主唱人声和音乐混合的音频流。听众只需调用 `playSong` 进入歌曲播放状态即可。

```Kotlin
ktvApiProtocol.loadSong(
    "ABCDEFG", KTVSongConfiguration(KTVSongType.KTVSongTypeSolo, KTVSingRole.KTVSingRoleAudience, "ABCDEFG", 12345, 0) // 听众可以不填演唱者 UID
) { songCode, lyricUrl, singRole, singState ->
    if (singState === KTVLoadSongState.KTVLoadSongStateOK) {
        // 歌曲加载成功后，进入歌曲播放状态
        ktvApiProtocol.playSong(songCode)
    }
}
```

#### 3. 停止播放

当歌曲播放完成或用户中途结束播放时，你需要主动调用 `stopSong` 停止播放。

```Kotlin
ktvApiProtocol.stopSong()
```

#### 4. 根据角色更新媒体选项

通过 [`updateChannelMediaOptions`](https://docs.agora.io/cn/online-ktv/API%20Reference/java_ng/API/toc_core_method.html#api_irtcengine_updatechannelmediaoptions) 方法在听众加入频道后更新频道媒体选项，例如是否开启本地音频采集，是否发布本地音频流等。

听众的用户角色为 AgoraClientRoleAudience，因此无法在频道内发布音频流。如果听众想上麦与主唱语聊，需要将用户角色修改为 AgoraClientRoleBroadcaster。修改角色后，SDK 默认发布该连麦听众的音频流，主唱和其他听众都能听到连麦听众的声音。

```Kotlin
// 针对需要上麦聊天的听众更新媒体选项
val channelMediaOption = ChannelMediaOptions()
// 发布本地麦克风流
channelMediaOption.publishMicrophoneTrack = true
// 启用音频采集和播放
channelMediaOption.enableAudioRecordingOrPlayout = true
// 设置角色为主播
channelMediaOption.clientRoleType = CLIENT_ROLE_BROADCASTER
// 更新媒体选项
mRtcEngine.updateChannelMediaOptions(channelMediaOption)


// 针对未上麦的听众更新媒体选项
val channelMediaOption = ChannelMediaOptions()
// 不发布本地麦克风流
channelMediaOption.publishMicrophoneTrack = false
// 启用音频采集和播放
channelMediaOption.enableAudioRecordingOrPlayout = true
// 设置角色为用户
channelMediaOption.clientRoleType = CLIENT_ROLE_AUDIENCE
// 更新媒体选项
mRtcEngine.updateChannelMediaOptions(channelMediaOption)
```

## 合唱

本节介绍如何实现合唱功能。主唱点歌开唱后，伴唱可以和主唱一起唱歌，K 歌房内的听众都可以听到合唱。房间内想与主唱或伴唱连麦语聊的听众可以上麦。

### 方案介绍

合唱场景下存在三种角色：

- 主唱：加入频道，加载并播放歌曲，发布麦克风采集的音频流。KTV API 模块内部控制音乐播放器播放音乐，发布音乐到远端，将音乐播放进度同步到远端，让歌词组件进入歌词滚动状态等逻辑。
- 伴唱：加入频道，加载并播放歌曲，发布麦克风采集的音频流。KTV API 模块内部控制音乐播放器播放音乐，同步主唱的音乐播放进度，让歌词组件进入歌词滚动状态等逻辑。
- 听众：加入频道，加载歌曲。KTV API 模块内部控制听众订阅主唱的人声和音乐的音频合流，同步主唱的音乐播放进度，让歌词组件进入歌词滚动状态等逻辑。如果普通观众需要上麦聊天，可以更新媒体选项。

![](https://web-cdn.agora.io/docs-files/1678784685024)

下图展示合唱的 API 调用时序图：

![](https://web-cdn.agora.io/docs-files/1678866284780)

### 主唱实现

#### 1. 设置合唱私有参数

实时合唱场景对低延时和音质的要求很高。开启合唱前，你需要在初始化 RtcEngine 引擎的方法里设置如下私有参数。

```Kotlin
mRtcEngine.setParameters("{\"rtc.ntp_delay_drop_threshold\":1000}");
mRtcEngine.setParameters("{\"che.audio.agc.enable\": true}");
mRtcEngine.setParameters("{\"rtc.video.enable_sync_render_ntp\": true}");
mRtcEngine.setParameters("{\"rtc.net.maxS2LDelay\": 800}");
```

#### 2. 加入频道

调用 [`joinChannel`](https://docs.agora.io/cn/online-ktv/API%20Reference/java_ng/API/toc_core_method.html#api_irtcengine_joinchannel2) 让主唱加入频道。

```Kotlin
// 加入频道
mRtcEngine.joinChannel(
	<Your_Rtc_Token>,
	<Your_Channel_Name>,
	<Your_Uid>,
    // 媒体选项详见第 5 步操作
	channelMediaOption
)
```

#### 3. 开始合唱

调用 `loadSong` 加载歌曲。歌曲加载结果会异步地通过 `onLoaded` 回调通知你。收到 `onLoaded(KTVLoadSongStateOK)` 回调状态后，调用 `playSong` 开始播放歌曲，开始合唱。

```Kotlin
ktvApiProtocol.loadSong(
    "ABCDEFG", KTVSongConfiguration(KTVSongType.KTVSongTypeChorus, KTVSingRole.KTVSingRoleMainSinger, "ABCDEFG", 12345, 0) // 主唱可以不填伴唱 UID，传 0 即可。
) { songCode, lyricUrl, singRole, singState ->
    if (singState === KTVLoadSongState.KTVLoadSongStateOK) {
        // 歌曲加载成功，则播放歌曲
        ktvApiProtocol.playSong(songCode)
    }
}
```

#### 4. 停止合唱

当歌曲播放完成或用户中途结束播放时，你需要主动调用 `stopSong` 停止播放，停止合唱。

```Kotlin
ktvApiProtocol.stopSong()
```

#### 5. 根据角色更新媒体选项

通过 [`updateChannelMediaOptions`](https://docs.agora.io/cn/online-ktv/API%20Reference/java_ng/API/toc_core_method.html#api_irtcengine_updatechannelmediaoptions) 方法在主播加入频道后更新频道媒体选项，例如是否开启本地音频采集，是否发布本地音频流等。

```Kotlin
val channelMediaOption = ChannelMediaOptions()
// 发布本地麦克风流
channelMediaOption.publishMicrophoneTrack = true
// 启用音频采集和播放
channelMediaOption.enableAudioRecordingOrPlayout = true
// 设置角色为主播
channelMediaOption.clientRoleType = CLIENT_ROLE_BROADCASTER
// 更新媒体选项
mRtcEngine.updateChannelMediaOptions(channelMediaOption)
```

### 伴唱实现

#### 1. 设置合唱私有参数

实时合唱场景对低延时和音质的要求很高。开启合唱前，你需要在初始化 RtcEngine 引擎的方法里设置如下私有参数。

```Kotlin
mRtcEngine.setParameters("{\"rtc.ntp_delay_drop_threshold\":1000}");
mRtcEngine.setParameters("{\"che.audio.agc.enable\": true}");
mRtcEngine.setParameters("{\"rtc.video.enable_sync_render_ntp\": true}");
mRtcEngine.setParameters("{\"rtc.net.maxS2LDelay\": 800}");
```

#### 2. 加入频道

调用 [`joinChannel`](https://docs.agora.io/cn/online-ktv/API%20Reference/java_ng/API/toc_core_method.html#api_irtcengine_joinchannel2) 让伴唱加入频道。

```Kotlin
// 加入频道
mRtcEngine.joinChannel(
	<Your_Rtc_Token>,
	<Your_Channel_Name>,
	<Your_Uid>,
    // 媒体选项详见第 5 步操作
	channelMediaOption
)
```

#### 3. 开始合唱

调用 `loadSong` 加载歌曲。歌曲加载结果会异步地通过 `onLoaded` 回调通知你。收到 `onLoaded(KTVLoadSongStateOK)` 回调状态后，调用 `playSong` 开始播放歌曲，开始合唱。

```Kotlin
ktvApiProtocol.loadSong(
    "ABCDEFG", KTVSongConfiguration(KTVSongType.KTVSongTypeChorus, KTVSingRole.KTVSingRoleCoSinger, "ABCDEFG", 12345, 54321) // 伴唱一定要填主唱 UID
) { songCode, lyricUrl, singRole, singState ->
    if (singState === KTVLoadSongState.KTVLoadSongStateOK) {
        // 歌曲加载成功，则播放歌曲
        ktvApiProtocol.playSong(songCode)
    }
}
```

#### 4. 停止合唱

当歌曲播放完成或用户中途结束播放时，你需要主动调用 `stopSong` 停止播放，停止合唱。

```Kotlin
ktvApiProtocol.stopSong()
```

#### 5. 根据角色更新媒体选项

通过 [`updateChannelMediaOptions`](https://docs.agora.io/cn/online-ktv/API%20Reference/java_ng/API/toc_core_method.html#api_irtcengine_updatechannelmediaoptions) 方法在伴唱加入频道后更新频道媒体选项，例如是否开启本地音频采集，是否发布本地音频流等。

```Kotlin
val channelMediaOption = ChannelMediaOptions()
// 发布本地麦克风流
channelMediaOption.publishMicrophoneTrack = true
// 启用音频采集和播放
channelMediaOption.enableAudioRecordingOrPlayout = true
// 设置角色为主播
channelMediaOption.clientRoleType = CLIENT_ROLE_BROADCASTER
// 更新媒体选项
mRtcEngine.updateChannelMediaOptions(channelMediaOption)
```

### 听众实现

#### 1. 加入频道

调用 [`joinChannel`](https://docs.agora.io/cn/online-ktv/API%20Reference/java_ng/API/toc_core_method.html#api_irtcengine_joinchannel2) 让听众加入频道。

```Kotlin
// 加入频道
mRtcEngine.joinChannel(
	<Your_Rtc_Token>,
	<Your_Channel_Name>,
	<Your_Uid>,
    // 媒体选项详见第 4 步操作
	channelMediaOption
)
```

#### 2. 加载歌曲

调用 `loadSong` 加载歌曲。加载结果会异步地通过 `onLoaded` 回调通知你。收到 `onLoaded(KTVLoadSongStateOK)` 回调状态后，调用 `playSong`。

听众加入频道后，默认订阅主唱发布的音频合流，即主唱人声和音乐混合的音频流。听众只需调用 `playSong` 进入歌曲播放状态即可。

```Kotlin
ktvApiProtocol.loadSong(
    "ABCDEFG", KTVSongConfiguration(KTVSongType.KTVSongTypeChorus, KTVSingRole.KTVSingRoleAudience, "ABCDEFG", 0, 0) // 听众可以不填演唱者 UID
) { songCode, lyricUrl, singRole, singState ->
    if (singState === KTVLoadSongState.KTVLoadSongStateOK) {
        // 歌曲加载成功后，进入歌曲播放状态
        ktvApiProtocol.playSong(songCode)
    }
}
```

#### 3. 停止播放

当歌曲播放完成或用户中途结束播放时，你需要主动调用 `stopSong` 停止播放。

```Kotlin
ktvApiProtocol.stopSong()
```

#### 4. 根据角色更新媒体选项

通过 [`updateChannelMediaOptions`](https://docs.agora.io/cn/online-ktv/API%20Reference/java_ng/API/toc_core_method.html#api_irtcengine_updatechannelmediaoptions) 方法在听众加入频道后更新频道媒体选项，例如是否开启本地音频采集，是否发布本地音频流等。

听众的用户角色为 AgoraClientRoleAudience，因此无法在频道内发布音频流。如果听众想上麦与主唱语聊，需要将用户角色修改为 AgoraClientRoleBroadcaster。修改角色后，SDK 默认发布该连麦听众的音频流，主唱和其他听众都能听到连麦听众的声音。

```Kotlin
// 针对需要上麦聊天的听众更新媒体选项
val channelMediaOption = ChannelMediaOptions()
// 发布本地麦克风流
channelMediaOption.publishMicrophoneTrack = true
// 启用音频采集和播放
channelMediaOption.enableAudioRecordingOrPlayout = true
// 设置角色为主播
channelMediaOption.clientRoleType = CLIENT_ROLE_BROADCASTER
// 更新媒体选项
mRtcEngine.updateChannelMediaOptions(channelMediaOption)


// 针对未上麦的听众更新媒体选项
val channelMediaOption = ChannelMediaOptions()
// 不发布本地麦克风流
channelMediaOption.publishMicrophoneTrack = false
// 启用音频采集和播放
channelMediaOption.enableAudioRecordingOrPlayout = true
// 设置角色为用户
channelMediaOption.clientRoleType = CLIENT_ROLE_AUDIENCE
// 更新媒体选项
mRtcEngine.updateChannelMediaOptions(channelMediaOption)
```

## API 参考

本文集成步骤中使用如下 API：
- [RTC API](/cn/online-ktv/API%20Reference/java_ng/API/rtc_api_overview_ng.html)
- [场景化 API](/cn/online-ktv/ktv_api_kotlin?platform=Android)