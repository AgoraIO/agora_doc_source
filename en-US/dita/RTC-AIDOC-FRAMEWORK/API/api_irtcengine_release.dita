<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE reference PUBLIC "-//OASIS//DTD DITA Reference//EN" "reference.dtd">
<reference id="api_irtcengine_release">
    <title><ph keyref="release"/></title>
    <shortdesc id="short"><ph id="shortdesc" props="electron">Destroys the <xref keyref="IRtcEngine"/> object.</ph><ph id="shortdesc" props="rn">Destroys the <xref keyref="IRtcEngine"/> object.</ph><ph id="shortdesc" props="flutter">Destroys the <xref keyref="IRtcEngine"/> object.</ph><ph id="shortdesc" props="unity">Destroys the <xref keyref="IRtcEngine"/> object.</ph></shortdesc>
    <prolog>
        <metadata>
            <keywords>
                <indexterm keyref="release"/>
            </keywords>
        </metadata>
    </prolog>
    <refbody>
        <section id="prototype">
            <p outputclass="codeblock">
                <codeblock props="electron" outputclass="language-typescript">abstract release(sync?: boolean): void;</codeblock>
                <codeblock props="rn" outputclass="language-typescript">abstract release(sync?: boolean): void;</codeblock>
                <codeblock props="flutter" outputclass="language-dart">Future&lt;void&gt; release({bool sync = false});</codeblock>
                <codeblock props="unity" outputclass="language-csharp">public abstract void Dispose(bool sync = false);</codeblock>
            </p>
        </section>
        <section id="detailed_desc" deliveryTarget="details" otherprops="no-title">
            <p props="electron">This method releases all resources used by the SDK. Some apps only use real-time audio and video communication when needed and release resources when not in use. This method is suitable for such cases.
After calling this method, you can no longer use any other SDK methods or callbacks. To use real-time audio and video communication again, you must call <xref keyref="createAgoraRtcEngine"/> and <xref keyref="initialize"/> again to create a new <xref keyref="IRtcEngine"/> object.</p>
            <p props="rn">This method releases all resources used by the SDK. Some apps only use real-time audio and video communication when needed, and release the resources when not in use for other operations. This method is suitable for such cases.
After calling this method, you can no longer use other methods and callbacks of the SDK. To use the real-time audio and video communication function again, you must call <xref keyref="createAgoraRtcEngine"/> and <xref keyref="initialize"/> in sequence to create a new <xref keyref="IRtcEngine"/> object.</p>
            <p props="flutter">This method releases all resources used by the SDK. Some Apps only use real-time audio and video communication when needed, and release resources when not needed for other operations. This method is suitable for such cases.
After calling this method, you can no longer use other SDK methods and callbacks. To use real-time audio and video communication again, you must call <xref keyref="createAgoraRtcEngine"/> and <xref keyref="initialize"/> again to create a new <xref keyref="IRtcEngine"/> object.</p>
            <p props="unity">This method releases all resources used by the SDK. Some Apps only use real-time audio and video communication when needed and release resources when not needed. This method is suitable for such scenarios.
After calling this method, you can no longer use other SDK methods or callbacks. To use real-time audio and video communication again, you must call <xref keyref="createAgoraRtcEngine"/> and <xref keyref="initialize"/> in sequence to create a new <xref keyref="IRtcEngine"/> object.</p>
            <note props="electron">
                <ul>
                    <li>This method is a synchronous call. You must wait for the <xref keyref="IRtcEngine"/> resources to be released before performing other operations (e.g., creating a new <xref keyref="IRtcEngine"/> object). Therefore, it is recommended to call this method in a sub-thread to avoid blocking the main thread.</li>
                    <li>It is not recommended to call <xref keyref="release"/> in an SDK callback. Otherwise, a deadlock may occur because the SDK needs to wait for the callback to return before reclaiming related object resources.</li>
                </ul>
            </note>
            <note props="rn">
                <ul>
                    <li>This method is a synchronous call. You need to wait for the <xref keyref="IRtcEngine"/> resources to be released before performing other operations (such as creating a new <xref keyref="IRtcEngine"/> object), so it is recommended to call this method in a sub-thread to avoid blocking the main thread.</li>
                    <li>It is not recommended to call <xref keyref="release"/> in the SDK's callback, otherwise the SDK will wait for the callback to return before recycling the related object resources, which may cause a deadlock.</li>
                </ul>
            </note>
            <note props="flutter">
                <ul>
                    <li>This method is a synchronous call. You must wait for the <xref keyref="IRtcEngine"/> resources to be released before performing other operations (e.g., creating a new <xref keyref="IRtcEngine"/> object), so it is recommended to call this method in a sub-thread to avoid blocking the main thread.</li>
                    <li>It is not recommended to call <xref keyref="release"/> within SDK callbacks, as the SDK must wait for the callback to return before recycling related object resources, which may cause a deadlock.</li>
                </ul>
            </note>
            <note props="unity">
                <ul>
                    <li>This method is a synchronous call. You must wait for the <xref keyref="IRtcEngine"/> resources to be released before performing other operations (e.g., creating a new <xref keyref="IRtcEngine"/> object). Therefore, it is recommended to call this method in a sub-thread to avoid blocking the main thread.</li>
                    <li>It is not recommended to call <xref keyref="release"/> inside SDK callbacks. Otherwise, since the SDK waits for the callback to return before reclaiming related object resources, it may cause a deadlock.</li>
                </ul>
            </note>
        </section>
        <section id="parameters" deliveryTarget="details" props="electron flutter rn unity">
            <title>Parameters</title>
            <parml>
                <plentry props="electron">
                    <pt>sync</pt>
                    <pd>Whether this method is a synchronous call:
                        <ul>
                            <li><xref keyref="true"/>: This method is synchronous.</li>
                            <li><xref keyref="false"/>: This method is asynchronous. Currently, only synchronous calls are supported. Do not set this parameter to <xref keyref="false"/>.</li>
                        </ul>
                    </pd>
                </plentry>
                <plentry props="rn">
                    <pt>sync</pt>
                    <pd>Whether the method is a synchronous call:
                        <ul>
                            <li><xref keyref="true"/>: The method is synchronous.</li>
                            <li><xref keyref="false"/>: The method is asynchronous. Currently, only synchronous calls are supported. Do not set this parameter to this value.</li>
                        </ul>
                    </pd>
                </plentry>
                <plentry props="flutter">
                    <pt>sync</pt>
                    <pd>Whether this method is a synchronous call:
                        <ul>
                            <li><xref keyref="true"/>: This method is synchronous.</li>
                            <li><xref keyref="false"/>: This method is asynchronous. Currently, only synchronous calls are supported. Do not set this parameter to <xref keyref="false"/>.</li>
                        </ul>
                    </pd>
                </plentry>
                <plentry props="unity">
                    <pt>sync</pt>
                    <pd>Whether this method is called synchronously:
                        <ul>
                            <li><xref keyref="true"/>: The method is synchronous.</li>
                            <li><xref keyref="false"/>: The method is asynchronous. Currently, only synchronous calls are supported. Do not set this parameter to this value.</li>
                        </ul>
                    </pd>
                </plentry>
            </parml>
        </section>
    </refbody>
</reference>