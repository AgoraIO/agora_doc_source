# API注释自动化更新项目 - 实现方案

## 1. 项目架构设计

### 1.1 整体架构（简化版）
```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   HTML文档源    │───▶│   注释提取器    │───▶│   JSON文件      │
│   (按平台分离)  │    │  (解析&标准化)  │    │  (平台独立)     │
└─────────────────┘    └─────────────────┘    └─────────────────┘
                                                       │
┌─────────────────┐    ┌─────────────────┐            │
│   代码仓库      │◄───│   注释注入器    │◄───────────┘
│  (平台分支)     │    │  (定位&替换)    │
└─────────────────┘    └─────────────────┘
```

### 1.2 核心模块设计

#### 模块1：配置管理器 (ConfigManager)
- 管理平台配置、路径配置、搜索规则
- 为每个平台维护独立的配置

#### 模块2：HTML解析器 (HTMLParser)
- 解析不同类型的HTML文件
- 提取API信息和注释内容
- 处理HTML转义和格式化

#### 模块3：注释标准化器 (CommentNormalizer)
- 将HTML内容转换为标准化注释格式
- 应用注释模板

#### 模块4：代码定位器 (CodeLocator)
- 在代码仓库中精确定位API位置
- 支持多种搜索策略（signature优先，name备选）

#### 模块5：注释注入器 (CommentInjector)
- 安全地替换现有注释
- 保留@technical preview/@since/@deprecated信息

#### 模块6：日志管理器 (LogManager)
- 分级日志系统(debug/info/warning/error)
- 时间戳文件日志和控制台输出

## 2. 技术选型

### 2.1 编程语言：Python 3.8+
**理由：**
- 丰富的HTML解析库(BeautifulSoup4, lxml)
- 强大的文本处理能力
- 优秀的JSON处理支持
- 成熟的文件系统操作库

### 2.2 核心依赖库
```python
# HTML解析
beautifulsoup4==4.12.2
lxml==4.9.3

# 配置管理
pyyaml==6.0.1
jsonschema==4.19.0

# 命令行界面
click==8.1.7
rich==13.5.2          # 美化输出

# 日志处理
loguru==0.7.2         # 高级日志库

# 测试和质量
pytest==7.4.2
black==23.7.0
flake8==6.0.0
```

### 2.3 项目结构（简化版）
```
api_comment_updater/
├── src/
│   ├── config/
│   │   ├── __init__.py
│   │   ├── manager.py
│   │   └── schemas.py
│   ├── parsers/
│   │   ├── __init__.py
│   │   ├── html_parser.py
│   │   ├── toc_parser.py
│   │   ├── class_parser.py
│   │   └── enum_parser.py
│   ├── processors/
│   │   ├── __init__.py
│   │   └── comment_normalizer.py
│   ├── injectors/
│   │   ├── __init__.py
│   │   ├── code_locator.py
│   │   └── comment_injector.py
│   ├── utils/
│   │   ├── __init__.py
│   │   ├── file_utils.py
│   │   ├── text_utils.py
│   │   └── logger.py
│   └── main.py
├── config/
│   ├── platforms/
│   │   ├── cpp-ng.yml
│   │   ├── android-ng.yml
│   │   ├── ios-ng.yml
│   │   └── mac-ng.yml
│   ├── comment_templates.yml
│   └── repo_config.yml
├── output/           # 生成的JSON文件存放目录
│   ├── cpp-ng.json
│   ├── android-ng.json
│   ├── ios-ng.json
│   └── mac-ng.json
├── logs/            # 日志文件目录
├── tests/
├── docs/
├── requirements.txt
└── setup.py
```

## 3. 分阶段实施计划

### 阶段1：基础框架搭建 (2周)

#### 里程碑1.1：项目初始化 (3天)
- [ ] 创建项目结构和基础代码框架
- [ ] 设置开发环境和依赖管理
- [ ] 配置CI/CD基础设施
- [ ] 编写项目文档和开发规范

#### 里程碑1.2：配置管理系统 (4天)
- [ ] 实现ConfigManager核心功能
- [ ] 设计并实现配置文件格式
- [ ] 添加配置验证和错误处理
- [ ] 编写配置管理的单元测试

#### 里程碑1.3：HTML解析器基础版本 (7天)
- [ ] 实现基础HTML解析功能
- [ ] 支持toc_xxx.html文件解析
- [ ] 支持class_xxx.html文件解析
- [ ] 支持enum_xxx.html文件解析
- [ ] 处理XML转义字符
- [ ] 添加解析器的单元测试

### 阶段2：单平台完整实现 (3周)

#### 里程碑2.1：C++平台完整支持 (10天)
- [ ] 完善C++平台的HTML解析规则
- [ ] 实现注释标准化器
- [ ] 开发C++代码定位器
- [ ] 实现注释注入器基础版本
- [ ] 保留@technical preview/@since/@deprecated信息
- [ ] 端到端测试C++平台功能

#### 里程碑2.2：日志系统和错误处理 (7天)
- [ ] 实现分级日志系统（debug/info/warning/error）
- [ ] 配置时间戳文件日志输出
- [ ] 设置控制台日志过滤（默认warning级别）
- [ ] 添加HTML解析失败错误处理
- [ ] 添加API未找到警告处理
- [ ] 完善错误恢复和继续处理机制

#### 里程碑2.3：命令行界面 (4天)
- [ ] 设计用户友好的CLI界面
- [ ] 实现进度显示和状态报告
- [ ] 添加交互式确认功能
- [ ] 支持批量处理和配置切换

### 阶段3：多平台扩展 (4周)

#### 里程碑3.1：Android平台支持 (7天)
- [ ] 分析Android平台HTML差异
- [ ] 实现Java代码解析器
- [ ] 添加Android特定的映射规则
- [ ] 测试Android平台的完整流程

#### 里程碑3.2：iOS平台支持 (7天)  
- [ ] 分析iOS平台HTML差异
- [ ] 实现Objective-C代码解析器
- [ ] 添加iOS特定的映射规则
- [ ] 测试iOS平台的完整流程

#### 里程碑3.3：macOS平台支持 (7天)
- [ ] 分析macOS平台HTML差异  
- [ ] 复用和调整iOS解析器
- [ ] 添加macOS特定的映射规则
- [ ] 测试macOS平台的完整流程

#### 里程碑3.4：平台集成测试 (7天)
- [ ] 多平台端到端测试
- [ ] 验证不同平台的JSON输出
- [ ] 测试平台间的配置隔离
- [ ] 优化平台切换流程

### 阶段4：优化和完善 (1周)

#### 里程碑4.1：性能和稳定性优化 (7天)
- [ ] 优化大文件处理性能
- [ ] 完善错误处理和日志输出
- [ ] 添加配置验证机制
- [ ] 编写用户使用文档

## 4. 详细实现策略

### 4.1 HTML解析策略

#### 4.1.1 解析器设计模式
```python
class HTMLParserFactory:
    @staticmethod
    def create_parser(html_type: str, platform: str):
        if html_type == "toc":
            return TocHTMLParser(platform)
        elif html_type == "class":
            return ClassHTMLParser(platform)
        elif html_type == "enum":
            return EnumHTMLParser(platform)
        else:
            raise ValueError(f"Unknown HTML type: {html_type}")

class BaseHTMLParser:
    def __init__(self, platform: str):
        self.platform = platform
        self.soup = None
        
    def parse(self, html_content: str) -> dict:
        self.soup = BeautifulSoup(html_content, 'lxml')
        return self._extract_data()
        
    def _extract_data(self) -> dict:
        raise NotImplementedError
```

#### 4.1.2 关键信息提取规则
```python
class TocHTMLParser(BaseHTMLParser):
    def _extract_apis(self) -> List[dict]:
        apis = []
        api_sections = self.soup.find_all('article', {'class': 'topic reference nested1'})
        
        for section in api_sections:
            api_data = {
                'name': self._extract_api_name(section),
                'signature': self._extract_signature(section),
                'parent_class': self._extract_parent_class(section),
                'comment': self._extract_comment_content(section),
                'file': self._get_file_name()
            }
            apis.append(api_data)
        return apis
        
    def _extract_api_name(self, section) -> str:
        title_elem = section.find('h2', {'class': 'title topictitle2'})
        if title_elem:
            span_elem = title_elem.find('span', {'class': 'ph'})
            return span_elem.text.strip() if span_elem else ""
        return ""
```

### 4.2 注释生成策略

#### 4.2.1 模板系统设计
```python
class CommentTemplateManager:
    def __init__(self):
        self.templates = self._load_templates()
        
    def generate_comment(self, api_data: dict, platform: str) -> List[str]:
        template = self.templates[platform]
        return self._apply_template(template, api_data)
        
    def _apply_template(self, template: str, data: dict) -> List[str]:
        # 根据模板和数据生成标准化注释
        comment_lines = ["/**"]
        
        # @brief
        if data.get('brief'):
            comment_lines.append(f" * @brief {data['brief']}")
            comment_lines.append(" *")
            
        # @technical preview
        if data.get('technical_preview'):
            comment_lines.append(" * @technical preview")
            
        # @since
        if data.get('since'):
            comment_lines.append(f" * @since {data['since']}")
            
        # 其他字段...
        
        comment_lines.append(" */")
        return comment_lines
```

### 4.3 代码定位策略

#### 4.3.1 多层次搜索机制
```python
class CodeLocator:
    def __init__(self, repo_config: dict):
        self.repo_path = repo_config['repo_path']
        self.search_patterns = repo_config['api_folders']
        
    def locate_api(self, api_data: dict) -> Optional[str]:
        # 策略1: 精确签名匹配
        location = self._search_by_signature(api_data['signature'])
        if location:
            return location
            
        # 策略2: API名称匹配
        location = self._search_by_name(api_data['name'])
        if location:
            return location
            
        # 策略3: 模糊匹配
        return self._fuzzy_search(api_data)
        
    def _search_by_signature(self, signature: str) -> Optional[str]:
        # 使用正则表达式在指定目录中搜索完整签名
        escaped_signature = re.escape(signature)
        pattern = re.compile(escaped_signature)
        
        for file_path in self._get_search_files():
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()
                if pattern.search(content):
                    return file_path
        return None
```

### 4.4 平台独立的JSON格式

#### 4.4.1 单平台JSON结构
```json
{
    "platform": "cpp-ng",
    "generated_at": "2025-01-27T10:30:00Z",
    "api": [
        {
            "name": "createAgoraRtcEngine",
            "signature": "AGORA_API agora::rtc::IRtcEngine *AGORA_CALL createAgoraRtcEngine ()",
            "parent_class": "IRtcEngine",
            "file": "toc_initialize.html",
            "comment": [
                "/**",
                " * @brief Creates one IRtcEngine object.",
                " *",
                " * @details Currently, the Agora RTC SDK v4.x supports creating only one IRtcEngine object for each app.",
                " *",
                " * @return Pointer to the IRtcEngine object.",
                " */"
            ]
        }
    ],
    "class": [
        {
            "name": "EchoTestConfiguration",
            "signature": "struct EchoTestConfiguration",
            "file": "class_echotestconfiguration.html",
            "class_comment": [
                {
                    "type": "desc",
                    "comment": [
                        "/**",
                        " * @brief The configuration of the audio and video call loop test.",
                        " */"
                    ]
                },
                {
                    "type": "attribute",
                    "value": "enableAudio",
                    "comment": [
                        "/**",
                        " * @brief Whether to enable the audio device for the loop test.",
                        " */"
                    ]
                }
            ]
        }
    ],
    "enum": [
        {
            "name": "PROXY_TYPE",
            "file": "enum_proxytype.html",
            "enum_comment": [
                {
                    "type": "desc",
                    "comment": [
                        "/**",
                        " * @brief The cloud proxy type.",
                        " */"
                    ]
                },
                {
                    "type": "enumerator",
                    "value": "UDP_PROXY_TYPE",
                    "comment": [
                        "/**",
                        " * @brief The cloud proxy for the UDP protocol.",
                        " */"
                    ]
                }
            ]
        }
    ]
}
```

#### 4.4.2 注释注入器（简化版）
```python
class CommentInjector:
    def __init__(self, logger):
        self.logger = logger
        
    def inject_comment(self, file_path: str, api_data: dict) -> bool:
        try:
            # 读取文件内容
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()
            
            # 查找并替换注释
            updated_content = self._replace_comment(content, api_data)
            
            # 写回文件
            with open(file_path, 'w', encoding='utf-8') as f:
                f.write(updated_content)
                
            self.logger.info(f"Successfully updated comment for {api_data['name']} in {file_path}")
            return True
            
        except Exception as e:
            self.logger.error(f"Failed to inject comment for {api_data['name']}: {str(e)}")
            return False
            
    def _replace_comment(self, content: str, api_data: dict) -> str:
        # 查找现有注释并检查保留信息
        preserved_info = self._extract_preserved_info(content, api_data)
        
        # 生成新注释
        new_comment = self._generate_comment(api_data, preserved_info)
        
        # 替换注释
        return self._perform_replacement(content, api_data, new_comment)
        
    def _extract_preserved_info(self, content: str, api_data: dict) -> dict:
        # 提取需要保留的@technical preview/@since/@deprecated信息
        preserved = {}
        # 实现保留信息提取逻辑
        return preserved
```

## 5. 配置文件设计

### 5.1 主配置文件 (repo_config.yml)
```yaml
# 代码仓库配置
repo_path: "E:/agoratwrepo/rte_sdk"

# HTML文档路径配置
html_sources:
  cpp-ng: "en-US/dita/out/cpp-ng/API"
  android-ng: "en-US/dita/out/android-ng/API"
  ios-ng: "en-US/dita/out/ios-ng/API"
  mac-ng: "en-US/dita/out/mac-ng/API"

# 各平台搜索路径配置（分离设计）
platforms:
  cpp-ng:
    include:
      - "interface/cpp/*/*.h"
      - "interface/c/rte/rte_base/c/c_player.h"
    exclude:
      - "interface/cpp/*/internal/*.h"
      - "interface/cpp/api2/*"
      - "interface/cpp/rte/rte_base/rte_cpp_string.h"
      - "interface/cpp/rtm2/*"
      - "interface/cpp/sync_client/*"
  
  android-ng:
    include:
      - "proj.android/src/main/java/io/agora/*/*.java"
    exclude: []
  
  ios-ng:
    include:
      - "interface/objc/*.h"
      - "interface/objc/rte/*"
    exclude:
      - "interface/objc/api2/*"
      - "interface/objc/lang_cn/*"
      
  mac-ng:
    include:
      - "interface/objc/*.h"
      - "interface/objc/rte/*" 
    exclude:
      - "interface/objc/api2/*"
      - "interface/objc/lang_cn/*"

# 日志配置
logging:
  file_level: "debug"
  console_level: "warning"
  log_dir: "./logs"
  max_log_files: 30
```

### 5.2 平台特定配置 (cpp-ng.yml)
```yaml
platform: "cpp-ng"
language: "cpp"

# HTML解析规则
html_parsing:
  api_name_selector: "h2.title.topictitle2 span.ph"
  signature_selector: "section[id$='__prototype'] pre"
  parent_class_selector: "nav.related-links .linklist a"
  
# 注释模板（不包含since/deprecated，这些从现有代码保留）
comment_template: |
  /**
   * @brief {brief}
   * {technical_preview}
   * {preserved_since}
   * {preserved_deprecated}
   *
   * @details {details}
   *
   * @note {note}
   *
   * {parameters}
   *
   * @return {return}
   */

# 代码搜索模式
search_patterns:
  signature_patterns:
    - r"^{escaped_signature}$"
    - r"^\s*{escaped_signature}\s*;?\s*$"
  name_patterns:
    - r"\b{api_name}\b"

# 保留信息匹配模式
preserve_patterns:
  technical_preview: r"@technical\s+preview"
  since: r"@since\s+v?[\d\.]+"
  deprecated: r"@deprecated\s+v?[\d\.]+.*"
```

## 6. 测试策略

### 6.1 单元测试
- 每个模块独立的单元测试
- 覆盖率要求：>90%
- 特殊情况和边界条件测试

### 6.2 集成测试  
- 端到端工作流测试
- 多平台兼容性测试
- 错误恢复机制测试

### 6.3 验收测试
- 在真实代码仓库的小规模测试
- 注释质量人工审核
- 性能基准测试

## 7. 部署和维护

### 7.1 部署方案（简化版）
```bash
# 安装依赖
pip install -r requirements.txt

# 初始化配置
python -m api_comment_updater init --config-dir ./config

# 提取指定平台的注释（生成JSON）
python -m api_comment_updater extract --platform cpp-ng

# 注入注释到代码仓库
python -m api_comment_updater inject --platform cpp-ng --json-file output/cpp-ng.json

# 一体化流程（提取+注入）
python -m api_comment_updater update --platform cpp-ng

# 多平台批量处理
python -m api_comment_updater update --platform all
```

### 7.2 日志系统设计
```python
# 日志配置示例
from loguru import logger

# 配置文件日志（debug级别）
logger.add(
    "logs/api_updater_{time:YYYY-MM-DD}.log",
    level="DEBUG",
    rotation="1 day",
    retention="30 days",
    format="{time:YYYY-MM-DD HH:mm:ss} | {level} | {module}:{function}:{line} | {message}"
)

# 配置控制台日志（warning级别）
logger.add(
    sys.stdout,
    level="WARNING", 
    format="<green>{time:HH:mm:ss}</green> | <level>{level}</level> | {message}"
)

# 使用示例
logger.debug("开始解析HTML文件: {}", html_file)
logger.info("成功提取API: {}", api_name)
logger.warning("未找到API定义: {}", api_name)
logger.error("HTML解析失败: {}", error_msg)
```

### 7.3 维护计划
- 定期更新HTML解析规则
- 监控API变更和映射关系
- 根据反馈优化注释模板

## 8. 成功标准

### 8.1 功能标准（简化版）
- [ ] 支持4个平台的独立注释更新
- [ ] HTML解析成功率 >95%
- [ ] API定位成功率 >90%
- [ ] 完整的日志记录和错误处理

### 8.2 质量标准
- [ ] 代码覆盖率 >85%
- [ ] 关键功能零Bug
- [ ] 配置文档完整
- [ ] 工具使用简单直观

### 8.3 可维护性标准
- [ ] 新平台支持开发时间 <1周
- [ ] HTML格式变化适应能力强
- [ ] 错误诊断信息清晰完整

## 9. 关键改进总结

根据您的澄清回复，该实现方案进行了以下关键简化：

### 9.1 架构简化
✅ **平台独立处理**：每个平台生成独立的JSON文件，无需跨平台映射
✅ **移除复杂映射**：不再需要维护跨平台API映射配置文件
✅ **简化数据流**：HTML → JSON → 代码仓库，流程更清晰

### 9.2 功能简化  
✅ **版本信息保留**：不从HTML提取@since/@deprecated，而是保留代码中的现有信息
✅ **移除备份机制**：基于工作分支操作，无需复杂的备份回滚
✅ **专注核心功能**：专注于HTML解析和注释替换的核心流程

### 9.3 错误处理优化
✅ **分级日志系统**：文件debug级别，控制台warning级别
✅ **优雅错误处理**：HTML解析失败继续下一个，API未找到记录警告
✅ **时间戳日志**：便于问题追踪和调试

这个简化后的方案更加实用、可维护，专注解决核心问题，降低了实现复杂度和维护成本。
